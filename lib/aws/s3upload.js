/** @module koast/aws */
/* global exports, require */

'use strict';

var fs = require('fs');
var expect = require('chai').expect;
var _ = require('lodash');
var Q = require('q');

/**
 * Returns a connect handler which uploads data from
 * req.files.attachments to a specified S3 bucket.<br />
 *
 *
 * AWS options:
 * <pre><code>
 * {
 *   accessKeyId: String,
 *   secretAccessKey: String
 * }
 * </code></pre>
 *
 *
 * S3 options:
 * <pre><code>
 * {
 *   bucket: String,
 *   makeKey: Function(file),
 *   respond: Function(req, res, keyMap)
 * }
 * </code></pre>
 *
 * makeKey(req, file) should return the name of the file (the key)
 * you wish to save the uploaded file as on the s3 bucket.
 *
 * respond(req, res, keyMap) should actually write the response to the user.
 * keyMap is a map whose values are the s3 keys generated by makeKey, indexed
 * by the names used for the files in the multipart request
 *
 * TODO word that better...
 *
 */
exports.makeS3FileUploader = function (awsOpts, s3opts) {

  // Validate AWS global options
  expect(awsOpts.accessKeyId).to.be.a('string');
  expect(awsOpts.secretAccessKey).to.be.a('string');

  // Validate S3 options
  expect(s3opts.bucket).to.be.a('string');
  expect(s3opts.makeKey).to.be.a('function');
  expect(s3opts.respond).to.be.a('function');

  var AWS;
  var s3;

  try {
    AWS = require('aws-sdk');

    // Add properties of awsOpts to AWS.config
    AWS.config.update(awsOpts);

    s3 = new AWS.S3();
  } catch (e) {
    throw e;
  }

  return function (req, res) {

    var s3keys = {};

    // not sure why this hack works, but I have to make an
    // array and map over it with the builtin Array.map()
    // to get Q.all to fire correctly :(
    var hack = [];
    for (var property in req.files) {
      if (req.files.hasOwnProperty(property)) {
        hack.push({formKey: property, file: req.files[property]});
      }
    }

    var putObjPromises = hack.map(function(val) {
      var objKey = val.formKey;
      var file = val.file;

      var deferred = Q.defer();

      
      var s3key = s3opts.makeKey(req, file);
      var params = {
        Bucket: s3opts.bucket,
        Key: s3key,
        Body: fs.createReadStream(file.path),
        ACL: s3opts.acl,
        ContentType: file.mimetype
      };

      s3.putObject(params, function (err) {
        if (err) {
          deferred.reject(err); 
        } else {
          s3keys[objKey] = s3key;
          deferred.resolve(s3key);
        }
      });

      return deferred.promise;
    });

    Q.all(putObjPromises).then(function(vals) {
      s3opts.respond(req, res, s3keys);
    }, function(err) {
      //handle error
      if(s3opts.error) {
        s3opts.error(err, req, res, s3keys);
        return;
      }

      res.status(500);
      if(s3opts['500'].sendValue) {
        res.send(err);
      } else {
        res.end();
      }

    });
  };
};

